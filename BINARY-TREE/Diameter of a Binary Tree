THE Diameter of a Binary Tree IS LONGEST PATH BETWEEN TWO END NODES.


OP1= diameter(root->left)
op2= diameter(root->right)
op3= height(root->left)+1+height(root->right)   

3 no me se jo MAX aayga wahi Answer hoga




//THIS IS BRUT-FORCE APPROCH THIS TIME-COMPLAXITY= O(n^2)..

class Solution {
  public:
  int height(Node* node) {   // Find height code part
        // Base case
        if(node==NULL){
            return 0;
        }
        int left=height(node->left);
        int right=height(node->right);
        
        int ans= max(left,right)+1;
        return ans;
    }
    int diameter(Node* root) {
        // Your code here
        if(root==NULL) return 0;
        
        int op1= diameter(root->left);
        int op2= diameter(root->right);
        int op3= height(root->left)+height(root->right);
        
        int ans= max(op1,max(op2,op3));
        return ans;
    }
};






















THIS IS OPTIMAL SOLUTION O(N)  TIME COMPLAXITY..






class Solution {
  public:
  int height(Node* node) {
        // Base case
        if(node==NULL){
            return 0;
        }
        int left=height(node->left);
        int right=height(node->right);
        
        int ans= max(left,right)+1;
        return ans;
    }
    pair<int,int> diameterFast(Node* root)
    {
        if(root==NULL)
        {
            pair<int,int> p=make_pair(0,0);
            return p;
        }
        
        pair<int,int> left = diameterFast(root->left);
         pair<int,int> right = diameterFast(root->right);
         
         int op1= left.first;
         int op2= right.first;
         int op3= left.second+right.second;
         
         pair<int, int> ans;
         ans.first= max(op1, max(op2,op3));
         ans.second=max(left.second, right.second)+1;
         
         return ans;
    }
    int diameter(Node* root) {
        // Your code here
        return diameterFast(root).first;
    }
};
